/*
 * SPDX-FileCopyrightText: 2016-2019 Emanuele Vespa
 * SPDX-FileCopyrightText: 2018-2021 Smart Robotics Lab, Imperial College London, Technical University of Munich
 * SPDX-FileCopyrightText: 2019-2021 Nils Funk
 * SPDX-FileCopyrightText: 2020-2021 Sotiris Papatheodorou
 * SPDX-License-Identifier: BSD-3-Clause
 */

#ifndef SE_MESHING_IO_IMPL_HPP
#define SE_MESHING_IO_IMPL_HPP

namespace se {
namespace colours {
/**
 * The colours used for the various integration scales.
 */
static const std::vector<Eigen::Vector3f, Eigen::aligned_allocator<Eigen::Vector3f>> scale = {
    {102, 194, 165},
    {252, 141, 98},
    {141, 160, 203},
    {231, 138, 195},
    {166, 216, 84},
    {255, 217, 47},
    {229, 196, 148},
    {179, 179, 179}};
} // namespace colours

namespace detail {
static std::string format_as_comment(const std::string& s, const std::string& comment_prefix)
{
    std::string comment(comment_prefix);
    comment.reserve(s.size());
    for (size_t i = 0; i < s.size(); ++i) {
        // Add the comment prefix before all newlines except the terminating one.
        if (s[i] == '\n' && i < s.size() - 1) {
            comment.push_back(s[i]);
            comment.append(comment_prefix);
        }
        else {
            comment.push_back(s[i]);
        }
    }
    return comment;
}
} // namespace detail



namespace io {

template<typename FaceT>
int save_mesh_vtk(const Mesh<FaceT>& mesh,
                  const std::string& filename,
                  const Eigen::Matrix4f& T_WM,
                  const std::string&)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Unable to write file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;

    // Write the header.
    file << "# vtk DataFile Version 2.0\n";
    file << "Generated by semanticeight\n";
    file << "ASCII\n";
    file << "DATASET POLYDATA\n";

    // Write the vertices.
    file << "POINTS " << num_vertices << " float\n";
    for (size_t f = 0; f < num_faces; ++f) {
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            const Eigen::Vector3f vertex_W =
                (T_WM * mesh[f].vertexes[v].homogeneous()).template head<3>();
            file << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z() << "\n";
        }
    }

    // Write the faces.
    file << "POLYGONS " << num_faces << " " << num_faces * (1 + FaceT::num_vertexes) << "\n";
    for (size_t f = 0; f < num_faces; ++f) {
        file << FaceT::num_vertexes;
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v;
        }
        file << "\n";
    }

    // Write the vertex colours.
    file << "POINT_DATA " << num_vertices << "\n";
    file << "COLOR_SCALARS RGB 3\n";
    for (size_t f = 0; f < num_faces; ++f) {
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << static_cast<float>(mesh[f].r[v]) / UINT8_MAX << " "
                 << static_cast<float>(mesh[f].g[v]) / UINT8_MAX << " "
                 << static_cast<float>(mesh[f].b[v]) / UINT8_MAX << "\n";
        }
    }

    // Write the face scale.
    file << "SCALARS scale int 1\n";
    file << "LOOKUP_TABLE default\n";
    for (size_t f = 0; f < num_faces; ++f) {
        file << static_cast<int>(mesh[f].max_vertex_scale) << "\n";
    }
    // Write the face minimum observed distance.
    file << "SCALARS dist float 1\n";
    file << "LOOKUP_TABLE default\n";
    for (size_t f = 0; f < num_faces; ++f) {
        // ParaView doesn't like infs so store the largest float value instead.
        file << (std::isinf(mesh[f].min_dist_updated) ? FLT_MAX : mesh[f].min_dist_updated) << "\n";
    }
    // Write the face foreground probability.
    file << "SCALARS fg float 1\n";
    file << "LOOKUP_TABLE default\n";
    for (size_t f = 0; f < num_faces; ++f) {
        file << mesh[f].fg << "\n";
    }

    file.close();
    return 0;
}



template<typename FaceT>
int save_mesh_ply(const Mesh<FaceT>& mesh,
                  const std::string& filename,
                  const Eigen::Matrix4f& T_WM,
                  const std::string& metadata)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Unable to write file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;

    // Write header
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Generated by semanticeight\n";
    file << se::detail::format_as_comment(metadata, "comment ") << "\n";
    file << "element vertex " << num_vertices << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    file << "property float dist\n";
    file << "element face " << num_faces << "\n";
    file << "property list uchar int vertex_index\n";
    file << "property char scale\n";
    file << "property float dist\n";
    file << "property float fg\n";
    file << "end_header\n";

    // Write the vertices.
    for (size_t f = 0; f < num_faces; ++f) {
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            const Eigen::Vector3f vertex_W =
                (T_WM * mesh[f].vertexes[v].homogeneous()).template head<3>();
            file << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z();
            file << " " << static_cast<int>(mesh[f].r[v]) << " " << static_cast<int>(mesh[f].g[v])
                 << " " << static_cast<int>(mesh[f].b[v]);
            file << " " << mesh[f].min_dist_updated;
            file << "\n";
        }
    }

    // Write the faces.
    for (size_t f = 0; f < num_faces; ++f) {
        file << FaceT::num_vertexes;
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v;
        }
        // Write the integration scale.
        file << " " << static_cast<int>(mesh[f].max_vertex_scale);
        // Write the update distance.
        file << " " << mesh[f].min_dist_updated;
        // Write the foreground probability.
        file << " " << mesh[f].fg;
        file << "\n";
    }

    file.close();
    return 0;
}



template<typename FaceT>
int save_mesh_obj(const Mesh<FaceT>& mesh,
                  const std::string& filename,
                  const Eigen::Matrix4f& T_WM,
                  const std::string& metadata)
{
    // Open the file for writing.
    std::ofstream file(filename.c_str());
    if (!file.is_open()) {
        std::cerr << "Unable to write file " << filename << "\n";
        return 1;
    }

    const size_t num_faces = mesh.size();
    const size_t num_vertices = FaceT::num_vertexes * num_faces;

    // Write the header.
    file << "# Wavefront OBJ file\n";
    file << "# Generated by semanticeight\n";
    file << se::detail::format_as_comment(metadata, "# ") << "\n";
    file << "# vertex count: " << num_vertices << std::endl;
    file << "# face count: " << num_faces << std::endl;

    // Write the vertices.
    for (size_t f = 0; f < num_faces; ++f) {
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            const Eigen::Vector3f vertex_W =
                (T_WM * mesh[f].vertexes[v].homogeneous()).template head<3>();
            file << "v " << vertex_W.x() << " " << vertex_W.y() << " " << vertex_W.z() << "\n";
        }
    }

    // Write the faces.
    for (size_t f = 0; f < num_faces; ++f) {
        file << "f ";
        for (size_t v = 0; v < FaceT::num_vertexes; ++v) {
            file << " " << FaceT::num_vertexes * f + v + 1;
        }
        file << "\n";
    }

    file.close();
    return 0;
}

} // namespace io
} // namespace se

#endif // SE_MESHING_IO_IMPL_HPP
