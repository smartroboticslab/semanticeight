// SPDX-FileCopyrightText: 2021 Smart Robotics Lab, Imperial College London
// SPDX-FileCopyrightText: 2021 Sotiris Papatheodorou
// SPDX-License-Identifier: BSD-3-Clause

#include <algorithm>
#include <fstream>
#include <limits>

#include "se/pose_grid_history.hpp"

namespace se {

PoseGridHistory::PoseGridHistory(const Eigen::Vector3f& dimensions,
                                 const Eigen::Vector4f& resolution) :
        dim_(dimensions.x(), dimensions.y(), dimensions.z(), M_TAU_F),
        res_(resolution),
        inv_res_((1.0f / res_.array()).matrix()),
        size_((dim_.array() / res_.array()).matrix().cast<int>()),
        num_cells_(size_.prod()),
        grid_(num_cells_, 0)
{
}



void PoseGridHistory::record(const Eigen::Vector4f& pose)
{
    const size_t linear_idx = poseToIndex(pose);
    // Avoid overflow.
    if (grid_[linear_idx] < std::numeric_limits<DataType>::max()) {
        grid_[linear_idx]++;
    }
}



void PoseGridHistory::record(const Eigen::Matrix4f& pose)
{
    const Eigen::Vector3f t = pose.topRightCorner<3, 1>();
    record(Eigen::Vector4f(t.x(), t.y(), t.z(), getYaw(pose)));
}



PoseGridHistory::DataType PoseGridHistory::get(const Eigen::Vector4f& pose) const
{
    return grid_[poseToIndex(pose)];
}



PoseGridHistory::DataType PoseGridHistory::get(const Eigen::Matrix4f& pose) const
{
    const Eigen::Vector3f t = pose.topRightCorner<3, 1>();
    return get(Eigen::Vector4f(t.x(), t.y(), t.z(), getYaw(pose)));
}



float PoseGridHistory::rejectionProbability(const Eigen::Vector3f& position) const
{
    // Count the visited yaw angles for this position.
    float visited_yaw = 0;
    for (float yaw = 0.0f; yaw < M_TAU_F; yaw += res_[3]) {
        const Eigen::Vector4f pose(position.x(), position.y(), position.z(), yaw);
        visited_yaw += (get(pose) > 0);
    }
    return visited_yaw / size_[3];
}



Eigen::Vector3f PoseGridHistory::dimensions() const
{
    return dim_.head<3>();
}



Eigen::Vector4f PoseGridHistory::resolution() const
{
    return res_;
}



Eigen::Vector4i PoseGridHistory::dimensionsCells() const
{
    return size_;
}



size_t PoseGridHistory::size() const
{
    return num_cells_;
}



PoseVector PoseGridHistory::neighbourPoses(const Eigen::Matrix4f& pose,
                                           const SensorImpl& /* sensor */) const
{
    const Eigen::Vector3f t = pose.topRightCorner<3, 1>();
    PoseVector neighbours;
    for (int yaw = 0; yaw < size_.w(); yaw++) {
        const Eigen::Vector4i indices = poseToIndices(Eigen::Vector4f(t.x(), t.y(), t.z(), yaw));
        const size_t idx = indicesToLinearIndex(indices);
        if (grid_[idx]) {
            const Eigen::Vector4f p = indicesToPose(indices);
            Eigen::Matrix4f T = Eigen::Matrix4f::Identity();
            T.topRightCorner<3, 1>() = p.head<3>();
            T(0, 0) = cos(p.w());
            T(0, 1) = -sin(p.w());
            T(1, 0) = sin(p.w());
            T(1, 1) = cos(p.w());
            neighbours.push_back(T);
        }
    }
    return neighbours;
}



PoseGridHistory::XYZYawVector PoseGridHistory::visitedPoses() const
{
    PoseGridHistory::XYZYawVector visited_poses;
    for (size_t i = 0; i < size(); i++) {
        if (grid_[i]) {
            visited_poses.push_back(indexToPose(i));
        }
    }
    return visited_poses;
}



bool PoseGridHistory::writeGridMesh(const std::string& filename) const
{
    static constexpr int vertices_per_cell = 8;
    static constexpr int faces_per_cell = 6;
    static constexpr int vertices_per_face = 4;

    const size_t num_xyz_cells = size_.head<3>().prod();
    const size_t num_vertices = vertices_per_cell * num_xyz_cells;
    const size_t num_faces = faces_per_cell * num_xyz_cells;

    std::ofstream file(filename);
    if (!file.good()) {
        return false;
    }

    // Write header
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Generated by semanticeight\n";
    file << "element vertex " << num_vertices << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    file << "element face " << num_faces << "\n";
    file << "property list uchar int vertex_index\n";
    file << "end_header\n";

    // Write the vertices of each cell aggregating the yaw
    for (float x = 0.0f; x < dim_.x(); x += res_.x()) {
        for (float y = 0.0f; y < dim_.y(); y += res_.y()) {
            for (float z = 0.0f; z < dim_.z(); z += res_.z()) {
                size_t data_sum = 0;
                for (float yaw = 0.0f; yaw < dim_.w(); yaw += res_.w()) {
                    data_sum += grid_[poseToIndex(Eigen::Vector4f(x, y, z, yaw))];
                }
                for (int v = 0; v < vertices_per_cell; v++) {
                    static const Eigen::Array3f vertex_offsets[vertices_per_cell] = {{0, 0, 0},
                                                                                     {1, 0, 0},
                                                                                     {0, 1, 0},
                                                                                     {1, 1, 0},
                                                                                     {0, 0, 1},
                                                                                     {1, 0, 1},
                                                                                     {0, 1, 1},
                                                                                     {1, 1, 1}};
                    const Eigen::Array3f position =
                        Eigen::Array3f(x, y, z) + vertex_offsets[v] * res_.head<3>().array();
                    file << position.x() << " " << position.y() << " " << position.z() << " "
                         << data_sum << " 0 0\n";
                }
            }
        }
    }

    // Write the faces of each aggregate cell
    for (size_t i = 0; i < num_xyz_cells; i++) {
        for (size_t f = 0; f < faces_per_cell; f++) {
            file << vertices_per_face;
            for (size_t v = 0; v < vertices_per_face; v++) {
                static constexpr size_t face_vertex_idx[faces_per_cell][vertices_per_face] = {
                    {0, 1, 3, 2},
                    {1, 5, 7, 3},
                    {5, 7, 6, 4},
                    {0, 2, 6, 4},
                    {0, 1, 5, 4},
                    {2, 3, 7, 6}};
                const size_t relative_vertex_offset = face_vertex_idx[f][v];
                const size_t absolute_vertex_offset = vertices_per_cell * i;
                file << " " << absolute_vertex_offset + relative_vertex_offset;
            }
            file << "\n";
        }
    }

    file.close();
    return file.good();
}



bool PoseGridHistory::writeWedgeMesh(const std::string& filename) const
{
    static constexpr int vertices_per_wedge = 6;
    static constexpr int faces_per_wedge = 8;
    static constexpr int vertices_per_face = 3;

    const auto visited_poses = visitedPoses();
    const size_t num_wedges = visited_poses.size();
    const size_t num_vertices = vertices_per_wedge * num_wedges;
    const size_t num_faces = faces_per_wedge * num_wedges;

    std::ofstream file(filename);
    if (!file.good()) {
        return false;
    }

    // Write header
    file << "ply\n";
    file << "format ascii 1.0\n";
    file << "comment Generated by semanticeight\n";
    file << "element vertex " << num_vertices << "\n";
    file << "property float x\n";
    file << "property float y\n";
    file << "property float z\n";
    file << "property uchar red\n";
    file << "property uchar green\n";
    file << "property uchar blue\n";
    file << "element face " << num_faces << "\n";
    file << "property list uchar int vertex_index\n";
    file << "end_header\n";

    // Write the vertices of each orientation wedge
    for (const auto& t : visited_poses) {
        Eigen::Array3f wedge_vertices[vertices_per_wedge] = {
            {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}, {0, 0, 0}};
        const Eigen::Array3f half_xy_res(res_.x() / 2, res_.y() / 2, 0);
        const float half_yaw_res = res_.w() / 2;
        // Bottom center vertex
        wedge_vertices[0] = t.head<3>().array() + half_xy_res;
        // Bottom right vertex
        const float right_yaw = t.w() - half_yaw_res;
        const Eigen::Array3f right_normal(cos(right_yaw), sin(right_yaw), 0);
        wedge_vertices[1] = wedge_vertices[0] + half_xy_res * right_normal;
        // Bottom left vertex
        const float left_yaw = t.w() + half_yaw_res;
        const Eigen::Array3f left_normal(cos(left_yaw), sin(left_yaw), 0);
        wedge_vertices[2] = wedge_vertices[0] + half_xy_res * left_normal;
        // The top vertices are just translated along the z axis
        for (int i = 0; i < 3; i++) {
            wedge_vertices[i + 3] = wedge_vertices[i] + Eigen::Array3f(0, 0, res_.z());
        }
        for (int v = 0; v < vertices_per_wedge; v++) {
            file << wedge_vertices[v].x() << " " << wedge_vertices[v].y() << " "
                 << wedge_vertices[v].z() << " "
                 << (v == 0 || v == 3 ? 0 : static_cast<int>(grid_[poseToIndex(t)])) << " 0 0\n";
        }
    }

    // Write the faces of each orientation wedge
    for (size_t w = 0; w < num_wedges; w++) {
        for (size_t f = 0; f < faces_per_wedge; f++) {
            file << vertices_per_face;
            for (size_t v = 0; v < vertices_per_face; v++) {
                static constexpr size_t face_vertex_idx[faces_per_wedge][vertices_per_face] = {
                    {0, 1, 2},
                    {3, 4, 5},
                    {0, 1, 4},
                    {0, 4, 3},
                    {1, 2, 4},
                    {2, 5, 4},
                    {0, 5, 2},
                    {0, 3, 5}};
                const size_t relative_vertex_offset = face_vertex_idx[f][v];
                const size_t absolute_vertex_offset = vertices_per_wedge * w;
                file << " " << absolute_vertex_offset + relative_vertex_offset;
            }
            file << "\n";
        }
    }

    file.close();
    return file.good();
}



size_t PoseGridHistory::indicesToLinearIndex(const Eigen::Vector4i& indices) const
{
    // https://en.wikipedia.org/wiki/Row-major_order#Address_calculation_in_general
    // Row-major order allows for faster iteration over the yaw angles for a single position.
    return indices[3] + size_[3] * (indices[2] + size_[2] * (indices[1] + size_[1] * indices[0]));
}



Eigen::Vector4i PoseGridHistory::linearIndexToIndices(const size_t linear_idx) const
{
    Eigen::Vector4i indices;
    size_t tmp = linear_idx;
    for (int i = 3; i > 0; i--) {
        indices[i] = tmp % size_[i];
        tmp = tmp / size_[i];
    }
    indices[0] = tmp;
    return indices;
}



Eigen::Vector4i PoseGridHistory::poseToIndices(const Eigen::Vector4f& pose) const
{
    // Discretize the pose into cell indices.
    return (inv_res_.array() * pose.array()).matrix().cast<int>();
}



Eigen::Vector4f PoseGridHistory::indicesToPose(const Eigen::Vector4i& indices) const
{
    return (res_.array() * indices.array().cast<float>()).matrix();
}



size_t PoseGridHistory::poseToIndex(const Eigen::Vector4f& pose) const
{
    return indicesToLinearIndex(poseToIndices(pose));
}



Eigen::Vector4f PoseGridHistory::indexToPose(const size_t linear_idx) const
{
    return indicesToPose(linearIndexToIndices(linear_idx));
}



float PoseGridHistory::getYaw(const Eigen::Matrix4f& pose)
{
    return pose.topLeftCorner<3, 3>().eulerAngles(2, 1, 0).x();
}

} // namespace se
